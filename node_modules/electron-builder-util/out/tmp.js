"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TmpDir = undefined;

var _asyncExitHook;

function _load_asyncExitHook() {
    return _asyncExitHook = _interopRequireDefault(require("async-exit-hook"));
}

var _bluebirdLst;

function _load_bluebirdLst() {
    return _bluebirdLst = _interopRequireDefault(require("bluebird-lst"));
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _lazyVal;

function _load_lazyVal() {
    return _lazyVal = require("lazy-val");
}

var _os;

function _load_os() {
    return _os = require("os");
}

var _path = _interopRequireWildcard(require("path"));

var _fs;

function _load_fs() {
    return _fs = require("./fs");
}

var _util;

function _load_util() {
    return _util = require("./util");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let tmpFileCounter = 0;
const tmpDirManagers = new Set();
const tempDir = new (_lazyVal || _load_lazyVal()).Lazy(() => {
    let promise;
    const systemTmpDir = process.env.TEST_DIR || (0, (_os || _load_os()).tmpdir)();
    if ((_fsExtraP || _load_fsExtraP()).mkdtemp == null) {
        const dir = _path.join(systemTmpDir, (0, (_util || _load_util()).getTempName)("electron-builder"));
        promise = (0, (_fsExtraP || _load_fsExtraP()).mkdirs)(dir, { mode: 448 }).then(() => dir);
    } else {
        promise = (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${_path.join(systemTmpDir, "electron-builder")}-`);
    }
    return promise.then(dir => {
        (0, (_asyncExitHook || _load_asyncExitHook()).default)(callback => {
            const managers = Array.from(tmpDirManagers);
            tmpDirManagers.clear();
            if (callback == null) {
                for (const manger of managers) {
                    manger.cleanupSync();
                }
                try {
                    (0, (_fsExtraP || _load_fsExtraP()).removeSync)(dir);
                } catch (e) {
                    handleError(e, dir);
                }
                return;
            }
            // each instead of map to avoid fs overload
            (_bluebirdLst || _load_bluebirdLst()).default.each(managers, it => it.cleanup()).then(() => (0, (_fsExtraP || _load_fsExtraP()).remove)(dir)).then(() => callback()).catch(e => {
                try {
                    handleError(e, dir);
                } finally {
                    callback();
                }
            });
        });
        return dir;
    });
});
function handleError(e, file) {
    if (e.code !== "EPERM" && e.code !== "ENOENT") {
        // use only console.* instead of our warn on exit (otherwise nodeEmoji can be required on request)
        console.warn(`Cannot delete temporary "${file}": ${(e.stack || e).toString()}`);
    }
}
class TmpDir {
    constructor() {
        this.tempFiles = [];
        this.registered = false;
    }
    getTempDir(suffix) {
        return this.getTempFile(suffix, true);
    }
    getTempFile(suffix) {
        let isDir = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        let disposer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        return tempDir.value.then(it => {
            if (!this.registered) {
                this.registered = true;
                tmpDirManagers.add(this);
            }
            const result = `${it}${_path.sep}${(tmpFileCounter++).toString(16)}${suffix.length === 0 || suffix.startsWith(".") ? suffix : `-${suffix}`}`;
            this.tempFiles.push({ path: result, isDir, disposer });
            return result;
        });
    }
    cleanupSync() {
        const tempFiles = this.tempFiles;
        tmpDirManagers.delete(this);
        this.registered = false;
        if (tempFiles.length === 0) {
            return;
        }
        this.tempFiles = [];
        for (const file of tempFiles) {
            if (file.disposer != null) {
                // noinspection JSIgnoredPromiseFromCall
                file.disposer(file.path);
                continue;
            }
            try {
                if (file.isDir) {
                    (0, (_fsExtraP || _load_fsExtraP()).removeSync)(file.path);
                } else {
                    (0, (_fsExtraP || _load_fsExtraP()).unlinkSync)(file.path);
                }
            } catch (e) {
                handleError(e, file.path);
            }
        }
    }
    cleanup() {
        const tempFiles = this.tempFiles;
        tmpDirManagers.delete(this);
        this.registered = false;
        if (tempFiles.length === 0) {
            return (_bluebirdLst || _load_bluebirdLst()).default.resolve();
        }
        this.tempFiles = [];
        return (_bluebirdLst || _load_bluebirdLst()).default.map(tempFiles, it => {
            if (it.disposer != null) {
                return it.disposer(it.path);
            }
            return (it.isDir ? (0, (_fsExtraP || _load_fsExtraP()).remove)(it.path) : (0, (_fsExtraP || _load_fsExtraP()).unlink)(it.path)).catch(e => {
                handleError(e, it.path);
            });
        }, (_fs || _load_fs()).CONCURRENCY);
    }
}
exports.TmpDir = TmpDir; //# sourceMappingURL=tmp.js.map